import SwiftUI

/// A view for editing an existing goal, matching the Phase 2 UI of goal creation.
///
/// **How It Works:**
/// - Pre-populates all fields from the existing goal
/// - Uses the same header and form components as goal creation
/// - Tappable header icon opens appearance customization sheet
/// - Save button at bottom persists changes
///
/// **Usage:**
/// ```swift
/// .sheet(isPresented: $showEditSheet) {
///     GoalEditView(existingGoal: goal) { updatedGoal in
///         Task {
///             await viewModel.updateGoal(updatedGoal)
///         }
///     }
/// }
/// ```
struct GoalEditView: View {
    let existingGoal: Goal
    let onSave: (Goal) -> Void

    @Environment(\.colorScheme) private var colorScheme
    @Environment(\.dismiss) private var dismiss

    // MARK: - Form State

    @State private var goalName: String
    @State private var targetAmountText: String
    @State private var currentAmountText: String
    @State private var selectedType: GoalType
    @State private var selectedIcon: String?
    @State private var selectedColor: GoalPresetColor
    @State private var hasTargetDate: Bool
    @State private var targetDate: Date
    @State private var notes: String
    @State private var accountName: String?

    // MARK: - UI State

    @State private var showAppearanceSheet: Bool = false
    @State private var targetAmountError: String?
    @State private var isSaving: Bool = false

    @FocusState private var isNameFieldFocused: Bool

    // MARK: - Computed Properties

    /// The icon generated automatically from the goal name
    private var autoGeneratedIcon: String {
        GoalIconMapper.icon(for: goalName)
    }

    /// The icon to save - either the manually selected icon or the auto-generated one
    private var effectiveIcon: String {
        selectedIcon ?? autoGeneratedIcon
    }

    /// Whether the form is valid for saving.
    private var canSave: Bool {
        !goalName.trimmingCharacters(in: .whitespaces).isEmpty &&
        !targetAmountText.isEmpty &&
        (Decimal(string: targetAmountText) ?? 0) > 0
    }

    // MARK: - Initialization

    init(existingGoal: Goal, onSave: @escaping (Goal) -> Void) {
        self.existingGoal = existingGoal
        self.onSave = onSave

        // Pre-populate form state from existing goal
        _goalName = State(initialValue: existingGoal.name)
        _targetAmountText = State(initialValue: "\(existingGoal.targetAmount)")
        _currentAmountText = State(initialValue: "\(existingGoal.currentAmount)")
        _selectedType = State(initialValue: existingGoal.type)
        _hasTargetDate = State(initialValue: existingGoal.desiredDate != nil)
        _targetDate = State(initialValue: existingGoal.desiredDate ?? Calendar.current.date(byAdding: .year, value: 1, to: Date()) ?? Date())
        _notes = State(initialValue: existingGoal.notes ?? "")
        _accountName = State(initialValue: existingGoal.accountName)

        // Pre-populate color from hex
        let color = GoalPresetColor(rawValue: existingGoal.colorHex ?? GoalPresetColor.defaultColor.rawValue) ?? .amethyst
        _selectedColor = State(initialValue: color)

        // Pre-populate icon - if stored icon differs from auto-generated, it's a manual selection
        let autoIcon = GoalIconMapper.icon(for: existingGoal.name)
        if let storedIcon = existingGoal.iconName, storedIcon != autoIcon {
            _selectedIcon = State(initialValue: storedIcon)
        } else {
            _selectedIcon = State(initialValue: nil)
        }
    }

    // MARK: - Body

    var body: some View {
        NavigationStack {
            VStack(spacing: 0) {
                // Header with tappable icon (always customizable in edit mode)
                GoalCreationHeaderView(
                    goalName: $goalName,
                    isFocused: $isNameFieldFocused,
                    selectedIcon: selectedIcon,
                    selectedColor: selectedColor,
                    isCustomizable: true,
                    onCustomizeTapped: { showAppearanceSheet = true }
                )

                // Scrollable form content
                ScrollView {
                    GoalDetailsFormView(
                        targetAmountText: $targetAmountText,
                        currentAmountText: $currentAmountText,
                        selectedType: $selectedType,
                        hasTargetDate: $hasTargetDate,
                        targetDate: $targetDate,
                        notes: $notes,
                        accountName: $accountName,
                        targetAmountError: targetAmountError
                    )
                    .onChange(of: targetAmountText) { _, _ in
                        validateTargetAmount()
                    }

                    // Extra padding at bottom for button
                    Spacer(minLength: 100)
                }
                .scrollDismissesKeyboard(.interactively)

                // Bottom save button
                saveButton
            }
            .background(WinnieColors.background(for: colorScheme).ignoresSafeArea())
            .navigationBarTitleDisplayMode(.inline)
            .toolbar(.hidden, for: .navigationBar)
        }
        .presentationDragIndicator(.visible)
        .sheet(isPresented: $showAppearanceSheet) {
            GoalAppearanceSheet(
                selectedIcon: $selectedIcon,
                selectedColor: $selectedColor,
                autoGeneratedIcon: autoGeneratedIcon
            )
        }
    }

    // MARK: - Save Button

    private var saveButton: some View {
        VStack(spacing: 0) {
            Button(action: saveGoal) {
                Text("Save Changes")
                    .font(WinnieTypography.bodyM())
                    .fontWeight(.semibold)
                    .foregroundColor(WinnieColors.snow)
                    .frame(maxWidth: .infinity)
                    .frame(height: WinnieSpacing.buttonHeight)
                    .background(WinnieColors.amethystSmoke)
                    .clipShape(RoundedRectangle(cornerRadius: WinnieSpacing.buttonCornerRadius))
            }
            .disabled(!canSave || isSaving)
            .opacity(canSave ? 1.0 : 0.5)
            .buttonStyle(AccentButtonStyle())
        }
        .padding(.horizontal, WinnieSpacing.screenMarginMobile)
        .padding(.vertical, WinnieSpacing.m)
        .background(WinnieColors.background(for: colorScheme))
    }

    // MARK: - Validation

    private func validateTargetAmount() {
        if targetAmountText.isEmpty {
            targetAmountError = "Target amount is required"
        } else if let amount = Decimal(string: targetAmountText), amount <= 0 {
            targetAmountError = "Amount must be greater than zero"
        } else if Decimal(string: targetAmountText) == nil {
            targetAmountError = "Please enter a valid number"
        } else {
            targetAmountError = nil
        }
    }

    // MARK: - Save

    private func saveGoal() {
        // Final validation
        validateTargetAmount()

        guard canSave else { return }

        isSaving = true

        let targetAmount = Decimal(string: targetAmountText) ?? 0
        let currentAmount = Decimal(string: currentAmountText) ?? 0

        let updatedGoal = Goal(
            id: existingGoal.id,
            type: selectedType,
            name: goalName.trimmingCharacters(in: .whitespaces),
            targetAmount: targetAmount,
            currentAmount: currentAmount,
            desiredDate: hasTargetDate ? targetDate : nil,
            customReturnRate: existingGoal.customReturnRate,
            priority: existingGoal.priority,
            createdAt: existingGoal.createdAt,
            isActive: existingGoal.isActive,
            notes: notes.isEmpty ? nil : notes,
            colorHex: selectedColor.rawValue,
            iconName: effectiveIcon,
            accountName: accountName
        )

        // Call the callback - parent handles async save
        onSave(updatedGoal)

        // Dismiss the modal
        dismiss()
    }
}

// MARK: - Button Style

/// Custom button style with scale animation for accent buttons.
private struct AccentButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.97 : 1.0)
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: configuration.isPressed)
    }
}

// MARK: - Previews

#Preview("Edit House Goal") {
    GoalEditView(existingGoal: .sampleHouse) { goal in
        print("Updated goal: \(goal.name)")
    }
}

#Preview("Edit Vacation Goal") {
    GoalEditView(existingGoal: .sampleVacation) { goal in
        print("Updated goal: \(goal.name)")
    }
}

#Preview("Dark Mode") {
    GoalEditView(existingGoal: .sampleRetirement) { _ in }
        .preferredColorScheme(.dark)
}
